using AutoDtoConfig.Attributes;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace AutoDto
{
    [Generator]
    public partial class AutoDtoSourceGenerator : ISourceGenerator
    {
        private AutoDtoConfigurationAttribute configuration;
        public AutoDtoSourceGenerator(AutoDtoConfigurationAttribute configuration)
        {
            this.configuration = configuration;
        }

        public AutoDtoSourceGenerator()
        {
            configuration = new AutoDtoConfigurationAttribute();
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Code generation goes here
            var globalNamespace = context.Compilation.GlobalNamespace;
            if (globalNamespace == null)
            {
                Console.Error.WriteLine("Found null value for global namespace");
                return;
            }
            var dbContextType = RecurseNamespaceForTypeWithBaseTypeName(globalNamespace, "DbContext");
            if (dbContextType == null)
            {
                Console.Error.WriteLine("Missing type DbContext for DTO generation");
                return;
            }
            var userConfig = GetAttributeInstanceFromSymbol<AutoDtoConfigurationAttribute>(dbContextType);
            if (userConfig != null)
            {
                configuration = userConfig;
            }

            var typesToScaffold = GetTypesToScaffoldFromDbContext(dbContextType);

            var scaffoldedDtos = new List<ScaffoldedDto>();
            var mappedRequestTypeNames = new List<RequestTypeNameMappings>();
            foreach (var requestType in GetRequestTypesToScaffold())
            {
                var mappedTypeNames = new Dictionary<string, string>();
                foreach (var scaffoldInfo in typesToScaffold)
                {
                    var excludedByIgnore = scaffoldInfo.IgnoreAttribute != null
                            && (scaffoldInfo.IgnoreAttribute.RequestTypesWherePropertyIsIgnored & requestType) > 0;
                    if (excludedByIgnore)
                    {
                        continue;
                    }
                    var requestDto = ScaffoldRequestDto(requestType, scaffoldInfo);
                    scaffoldedDtos.Add(requestDto);
                    mappedTypeNames.Add(requestDto.BaseClassName, requestDto.ClassName);
                }
                mappedRequestTypeNames.Add(new RequestTypeNameMappings
                {
                    RequestType = requestType,
                    MappedTypeNames = mappedTypeNames,
                });
            }

            var mappedResponseTypeNames = new List<ResponseTypeNameMappings>();
            foreach (var responseType in GetResponseTypesToScaffold())
            {
                var mappedTypeNames = new Dictionary<string, string>();
                foreach (var scaffoldInfo in typesToScaffold)
                {
                    var excludedByIgnore = scaffoldInfo.IgnoreAttribute != null
                            && (scaffoldInfo.IgnoreAttribute.ResponseTypesWherePropertyIsIgnored & responseType) > 0;
                    if (excludedByIgnore)
                    {
                        continue;
                    }
                    var responseDto = ScaffoldResponseDto(responseType, scaffoldInfo);
                    scaffoldedDtos.Add(responseDto);
                    mappedTypeNames.Add(responseDto.BaseClassName, responseDto.ClassName);
                }
                mappedResponseTypeNames.Add(new ResponseTypeNameMappings
                {
                    ResponseType = responseType,
                    MappedTypeNames = mappedTypeNames,
                });
            }

            foreach (var dto in scaffoldedDtos)
            {
                try
                {
                    var source = GenerateSourceFromScaffoldedDto(new DtoSourceCodeMetadata
                    {
                        ScaffoldedDto = dto,
                        RequestTypeNameMappings = mappedRequestTypeNames,
                        ResponseTypeNameMappings = mappedResponseTypeNames,
                    });
                    context.AddSource(dto.ClassFileName, source);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(ex.ToString());
                }
            }
        }

        internal string GenerateSourceFromScaffoldedDto(DtoSourceCodeMetadata dtoSourceData)
        {
            var sourceBuilder = new StringBuilder($@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;

namespace AutoDto
{{
{"\t"}public partial class {dtoSourceData.ScaffoldedDto.ClassName}
{"\t"}{{
");
            Dictionary<string, string> nameMappings;
            if (dtoSourceData.ScaffoldedDto.IsRequestType)
            {
                nameMappings = dtoSourceData.RequestTypeNameMappings
                    .First(nm => nm.RequestType.Equals(dtoSourceData.ScaffoldedDto.RequestType))
                    .MappedTypeNames;
            }
            else
            {
                nameMappings = dtoSourceData.ResponseTypeNameMappings
                    .First(nm => nm.ResponseType.Equals(dtoSourceData.ScaffoldedDto.ResponseType))
                    .MappedTypeNames;
            }
            foreach (var property in dtoSourceData.ScaffoldedDto.Properties)
            {
                string generatedTypeName;
                if (nameMappings.ContainsKey(property.TypeName))
                {
                    generatedTypeName = nameMappings[property.TypeName];
                }
                else
                {
                    generatedTypeName = property.TypeName;
                }
                sourceBuilder.AppendLine("\t\t" + property.Template.Replace("{TypeName}", generatedTypeName));
            }

            sourceBuilder.AppendLine("\t}");
            sourceBuilder.AppendLine("}");
            sourceBuilder.AppendLine("");
            sourceBuilder.AppendLine("#nullable restore");
            return sourceBuilder.ToString();
        }

        public List<GeneratedRequestType> GetRequestTypesToScaffold()
        {
            var requestTypes = new List<GeneratedRequestType>();
            foreach (var requestType in new[] { 
                GeneratedRequestType.Create, 
                GeneratedRequestType.Read, 
                GeneratedRequestType.Update, 
                GeneratedRequestType.Delete })
            {
                if ((requestType & configuration.GenerateRequestTypes) > 0)
                {
                    requestTypes.Add(requestType);
                }
            }
            return requestTypes;
        }

        public List<GeneratedResponseType> GetResponseTypesToScaffold()
        {
            var requestTypes = new List<GeneratedResponseType>();
            foreach (var requestType in new[] {
                GeneratedResponseType.Create,
                GeneratedResponseType.Read,
                GeneratedResponseType.Update,
                GeneratedResponseType.Delete,
                GeneratedResponseType.Generic })
            {
                if ((requestType & configuration.GenerateResponseTypes) > 0)
                {
                    requestTypes.Add(requestType);
                }
            }
            return requestTypes;
        }

        internal T? GetAttributeInstanceFromSymbol<T>(ISymbol namedType)
            where T : new()
        {
            var typeAttributes = namedType.GetAttributes();
            var attributeTypeName = typeof(T).Name;
            foreach (var dbContextAttribute in typeAttributes)
            {
                if (dbContextAttribute.AttributeClass != null
                    && dbContextAttribute.AttributeClass.Name.Equals(attributeTypeName))
                {
                    return ConstructObjectFromNamedArguments<T>(dbContextAttribute.NamedArguments);
                }
            }
            return default(T);
        }

        internal T ConstructObjectFromNamedArguments<T>(ImmutableArray<KeyValuePair<string, TypedConstant>> namedArguments)
            where T : new()
        {
            T constructedObject = new T();
            foreach (var arg in namedArguments)
            {
                var argName = arg.Key;
                var argValue = arg.Value;
                var propertyInfo = constructedObject.GetType().GetProperty(argName);
                try
                {
                    propertyInfo.SetValue(constructedObject, argValue.Value);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine("Unable to set configuration property from attribute: " + ex.Message);
                }
            }
            return constructedObject;
        }

        internal List<TypeScaffoldingInfo> GetTypesToScaffoldFromDbContext(INamedTypeSymbol dbContextType)
        {
            var dbContextMembers = dbContextType.GetMembers();
            List<TypeScaffoldingInfo> typesToScaffold = new List<TypeScaffoldingInfo>();
            foreach (var dbMember in dbContextMembers)
            {
                if (dbMember.Kind.Equals(SymbolKind.Property))
                {
                    var typeSymbol = ((IPropertySymbol)dbMember).Type;
                    var typeName = typeSymbol.Name;
                    if (typeName.Equals("DbSet") && typeSymbol is INamedTypeSymbol)
                    {
                        var typeArguments = ((INamedTypeSymbol)typeSymbol).TypeArguments;
                        var baseClass = typeArguments.FirstOrDefault();
                        if (baseClass == null)
                        {
                            continue;
                        }
                        var includeAttribute = GetAttributeInstanceFromSymbol<AutoDtoIncludeAttribute>(baseClass);
                        var ignoreAttribute = GetAttributeInstanceFromSymbol<AutoDtoIgnoreAttribute>(baseClass);
                        if (configuration.ClassDiscoveryBehavior.Equals(ClassDiscoveryBehavior.ExcludeAll))
                        {
                            if (includeAttribute == null)
                            {
                                continue;
                            }
                        }
                        if (ignoreAttribute != null)
                        {
                            if (ignoreAttribute.ResponseTypesWherePropertyIsIgnored.Equals(GeneratedResponseType.All)
                                && ignoreAttribute.RequestTypesWherePropertyIsIgnored.Equals(GeneratedResponseType.All))
                            {
                                continue;
                            }
                        }
                        var classConfiguration = GetAttributeInstanceFromSymbol<AutoDtoConfigurationAttribute>(baseClass);
                        var properties = GetPropertiesToScaffold(baseClass);
                        typesToScaffold.Add(new TypeScaffoldingInfo
                        {
                            BaseType = baseClass!,
                            ClassConfiguration = classConfiguration,
                            IgnoreAttribute = ignoreAttribute,
                            IncludeAttribute = includeAttribute,
                            Properties = properties,
                        });
                    }
                }
            }
            return typesToScaffold;
        }

        internal List<PropertyScaffoldingInfo> GetPropertiesToScaffold(ITypeSymbol baseType)
        {
            var properties = new List<PropertyScaffoldingInfo>();
            foreach (var member in baseType.GetMembers())
            {
                if (member.Kind.Equals(SymbolKind.Property))
                {
                    var memberProperty = (IPropertySymbol)member;
                    var includeAttribute = GetAttributeInstanceFromSymbol<AutoDtoIncludeAttribute>(memberProperty);
                    var ignoreAttribute = GetAttributeInstanceFromSymbol<AutoDtoIgnoreAttribute>(memberProperty);
                    if (ignoreAttribute != null 
                        && ignoreAttribute.RequestTypesWherePropertyIsIgnored.Equals(GeneratedRequestType.All)
                        && ignoreAttribute.ResponseTypesWherePropertyIsIgnored.Equals(GeneratedRequestType.All))
                    {
                        continue;
                    }
                    properties.Add(new PropertyScaffoldingInfo
                    {
                        BaseProperty = memberProperty,
                        IncludeAttribute = includeAttribute,
                        IgnoreAttribute = ignoreAttribute,
                    });
                }
            }
            return properties;
        }

        internal ScaffoldedMember? GetScaffoldedProperty(PropertyScaffoldingInfo propertyScaffoldingInfo)
        {
            var propertySymbol = propertyScaffoldingInfo.BaseProperty;
            string typeName;
            switch (propertySymbol.Type.TypeKind)
            {
                case TypeKind.Class:
                    string nullableAnnotation = string.Empty;
                    string valueInitializer = " = null!;";
                    if (propertySymbol.Type.NullableAnnotation.Equals(NullableAnnotation.Annotated))
                    {
                        nullableAnnotation = "?";
                        valueInitializer = "";
                    }
                    if (propertySymbol.Type.OriginalDefinition.ToString().Contains("."))
                    {
                        typeName = propertySymbol.Type.Name;
                    }
                    else
                    {
                        typeName = propertySymbol.Type.OriginalDefinition.ToString();
                    }
                    return new ScaffoldedMember
                    {
                        TypeName = typeName,
                        Template = $"public {{TypeName}}{nullableAnnotation} {propertySymbol.Name} {{ get; set; }}{valueInitializer}"
                    };
                case TypeKind.Interface:
                    if (propertySymbol.Type is INamedTypeSymbol && propertySymbol.Type.Name.Equals("ICollection"))
                    {
                        var typeArguments = ((INamedTypeSymbol)propertySymbol.Type).TypeArguments;
                        var baseClass = typeArguments.FirstOrDefault();
                        if (baseClass != null)
                        {
                            return new ScaffoldedMember
                            {
                                TypeName = baseClass.Name,
                                Template = $"public ICollection<{{TypeName}}> {propertySymbol.Name} {{ get; set; }} = new List<{{TypeName}}>();"
                            };
                        }
                        else
                        {
                            if (propertySymbol.Type.OriginalDefinition.ToString().Contains("."))
                            {
                                typeName = propertySymbol.Type.Name;
                            }
                            else
                            {
                                typeName = propertySymbol.Type.OriginalDefinition.ToString();
                            }
                            return new ScaffoldedMember
                            {
                                TypeName = typeName,
                                Template = $"public {propertySymbol.Type.OriginalDefinition} {propertySymbol.Name} {{ get; set; }} = new {propertySymbol.Type.OriginalDefinition}();",
                            };
                        }
                    }
                    return null;
                default:
                    return null;

            }
        }

        public string GetScaffoldedRequestTypeName(string originalName, string namingTemplate, GeneratedRequestType requestType)
        {
            return namingTemplate
                .Replace("{BaseClassName}", originalName)
                .Replace("{RequestType}", requestType.ToString());
        }

        public string GetScaffoldedResponseTypeName(string originalName, string namingTemplate, GeneratedResponseType responseType)
        {
            var responseTypeName = responseType == GeneratedResponseType.Generic ? "" : responseType.ToString();
            return namingTemplate
                .Replace("{BaseClassName}", originalName)
                .Replace("{ResponseType}", responseTypeName);
        }

        internal ScaffoldedDto ScaffoldRequestDto(GeneratedRequestType requestType, TypeScaffoldingInfo scaffoldingInfo)
        {
            AutoDtoConfigurationAttribute activeConfig = scaffoldingInfo.ClassConfiguration ?? configuration;

            var includePropertiesByDefault = (activeConfig.RequestTypesIncludingAllPropertiesByDefault & requestType) > 0;
            var dtoName = GetScaffoldedRequestTypeName(scaffoldingInfo.BaseType.Name, activeConfig.RequestDtoNamingTemplate, requestType);
            var scaffoldedDto = new ScaffoldedDto
            {
                IsRequestType = true,
                RequestType = requestType,
                BaseClassName = scaffoldingInfo.BaseType.Name,
                ClassName = dtoName,
                ClassFileName = $"{dtoName}.cs",
                Properties = new List<ScaffoldedMember>()
            };
            foreach (var property in scaffoldingInfo.Properties)
            {
                if (property.IgnoreAttribute != null 
                    && (property.IgnoreAttribute.RequestTypesWherePropertyIsIgnored & requestType) > 0)
                {
                    continue;
                }
                var includeAttributeApplies = property.IncludeAttribute != null 
                    && (property.IncludeAttribute.RequestTypesWherePropertyIsIncluded & requestType) > 0;
                if (includeAttributeApplies || includePropertiesByDefault)
                {
                    var scaffoldedProperty = GetScaffoldedProperty(property);
                    if (scaffoldedProperty != null)
                    {
                        scaffoldedDto.Properties.Add(scaffoldedProperty);
                    }
                }
            }
            return scaffoldedDto;
        }

        internal ScaffoldedDto ScaffoldResponseDto(GeneratedResponseType responseType, TypeScaffoldingInfo scaffoldingInfo)
        {
            AutoDtoConfigurationAttribute activeConfig = scaffoldingInfo.ClassConfiguration ?? configuration;

            var includePropertiesByDefault = (activeConfig.ResponseTypesIncludingAllPropertiesByDefault & responseType) > 0;
            var dtoName = GetScaffoldedResponseTypeName(scaffoldingInfo.BaseType.Name, activeConfig.ResponseDtoNamingTemplate, responseType);
            var scaffoldedDto = new ScaffoldedDto
            {
                IsRequestType = false,
                ResponseType = responseType,
                BaseClassName = scaffoldingInfo.BaseType.Name,
                ClassName = dtoName,
                ClassFileName = $"{dtoName}.cs",
                Properties = new List<ScaffoldedMember>()
            };
            foreach (var property in scaffoldingInfo.Properties)
            {
                if (property.IgnoreAttribute != null
                    && (property.IgnoreAttribute.ResponseTypesWherePropertyIsIgnored & responseType) > 0)
                {
                    continue;
                }
                var includeAttributeApplies = property.IncludeAttribute != null
                    && (property.IncludeAttribute.ResponseTypesWherePropertyIsIncluded & responseType) > 0;
                if (includeAttributeApplies || includePropertiesByDefault)
                {
                    var scaffoldedProperty = GetScaffoldedProperty(property);
                    if (scaffoldedProperty != null)
                    {
                        scaffoldedDto.Properties.Add(scaffoldedProperty);
                    }
                }
            }
            return scaffoldedDto;
        }

        public INamedTypeSymbol? RecurseNamespaceForTypeWithBaseTypeName(INamespaceSymbol targetNamespace, string baseTypeName)
        {
            var types = targetNamespace.GetTypeMembers();
            foreach (var type in types)
            {
                if (type.BaseType != null && type.BaseType.Name.Equals(baseTypeName))
                {
                    return type;
                }
            }
            // type not found in target namespace; check child namespaces recursively
            foreach (var childNamespace in targetNamespace.GetNamespaceMembers())
            {
                var discoveredType = RecurseNamespaceForTypeWithBaseTypeName(childNamespace, baseTypeName);
                if (discoveredType != null)
                {
                    return discoveredType;
                }
            }
            return null;
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this one
#if DEBUG
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif 
            Debug.WriteLine("Initalize code generator");
        }
    }
}